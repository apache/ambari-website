"use strict";(self.webpackChunkambari_website=self.webpackChunkambari_website||[]).push([[8242],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>c});var r=i(96540);const t={},s=r.createContext(t);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:n},e.children)}},45280:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"ambari-design/kerberos/kerberos_descriptor","title":"The Kerberos Descriptor","description":"\x3c!---","source":"@site/versioned_docs/version-2.7.6/ambari-design/kerberos/kerberos_descriptor.md","sourceDirName":"ambari-design/kerberos","slug":"/ambari-design/kerberos/kerberos_descriptor","permalink":"/docs/2.7.6/ambari-design/kerberos/kerberos_descriptor","draft":false,"unlisted":false,"editUrl":"https://github.com/vivostar/vivostar.github.io/tree/master/versioned_docs/version-2.7.6/ambari-design/kerberos/kerberos_descriptor.md","tags":[],"version":"2.7.6","frontMatter":{"title":"The Kerberos Descriptor"},"sidebar":"ambariSidebar","previous":{"title":"Ambari Kerberos Automation","permalink":"/docs/2.7.6/kerberos"},"next":{"title":"The Kerberos Service","permalink":"/docs/2.7.6/ambari-design/kerberos/kerberos_service"}}');var t=i(74848),s=i(28453);const o={title:"The Kerberos Descriptor"},c=void 0,a={},l=[{value:"The Kerberos Descriptor",id:"the-kerberos-descriptor",level:2},{value:"Components of a Kerberos Descriptor",id:"components-of-a-kerberos-descriptor",level:3},{value:"Stack-level Properties",id:"stack-level-properties",level:4},{value:"Stack-level Identities",id:"stack-level-identities",level:4},{value:"Stack-level Auth-to-local-properties",id:"stack-level-auth-to-local-properties",level:4},{value:"Stack-level Configurations",id:"stack-level-configurations",level:4},{value:"Services",id:"services",level:4},{value:"Service-level Identities",id:"service-level-identities",level:4},{value:"Examples",id:"examples",level:5},{value:"Service-level Auth-to-local-properties",id:"service-level-auth-to-local-properties",level:4},{value:"Service-level Configurations",id:"service-level-configurations",level:4},{value:"Components",id:"components",level:4},{value:"Component-level Identities",id:"component-level-identities",level:4},{value:"Component-level Auth-to-local-properties",id:"component-level-auth-to-local-properties",level:4},{value:"Component-level Configurations",id:"component-level-configurations",level:4},{value:"Kerberos Descriptor Specifications",id:"kerberos-descriptor-specifications",level:3},{value:"properties",id:"properties",level:4},{value:"auth-to-local-properties",id:"auth-to-local-properties",level:4},{value:"configurations",id:"configurations",level:4},{value:"identities",id:"identities",level:4},{value:"principal",id:"principal",level:4},{value:"keytab",id:"keytab",level:4},{value:"services",id:"services-1",level:4},{value:"components",id:"components-1",level:4},{value:"Examples",id:"examples-1",level:3},{value:"Example Stack-level Kerberos Descriptor",id:"example-stack-level-kerberos-descriptor",level:4},{value:"Example Service-level Kerberos Descriptor",id:"example-service-level-kerberos-descriptor",level:4}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/2.7.6/kerberos",children:"Introduction"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#the-kerberos-descriptor",children:"The Kerberos Descriptor"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#components-of-a-kerberos-descriptor",children:"Components of a Kerberos Descriptor"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#stack-level-properties",children:"Stack-level Properties"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#stack-level-identities",children:"Stack-level Identities"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#stack-level-auth-to-local-properties",children:"Stack-level Auth-to-local-properties"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#stack-level-configurations",children:"Stack-level Configurations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#services",children:"Services"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#service-level-identities",children:"Service-level Identities"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#service-level-auth-to-local-properties",children:"Service-level Auth-to-local-properties"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#service-level-configurations",children:"Service-level Configurations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#components",children:"Components"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#component-level-identities",children:"Component-level Identities"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#component-level-auth-to-local-properties",children:"Component-level Auth-to-local-properties"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#component-level-configurations",children:"Component-level Configurations"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#kerberos-descriptor-specifications",children:"Kerberos Descriptor specifications"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#properties",children:"properties"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#auth-to-local-properties",children:"auth-to-local-properties"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#configurations",children:"configurations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#identities",children:"identities"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#principal",children:"principal"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#keytab",children:"keytab"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#services",children:"services"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#components",children:"components"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#examples",children:"Examples"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/2.7.6/ambari-design/kerberos/kerberos_service",children:"The Kerberos Service"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/2.7.6/ambari-design/kerberos/enabling_kerberos",children:"Enabling Kerberos"})}),"\n"]}),"\n",(0,t.jsx)("a",{name:"the-kerberos-descriptor"}),"\n",(0,t.jsx)(n.h2,{id:"the-kerberos-descriptor",children:"The Kerberos Descriptor"}),"\n",(0,t.jsxs)(n.p,{children:["The Kerberos Descriptor is a JSON-formatted text file containing information needed by Ambari to enable or disable Kerberos for a stack and its services. This file must be named ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"kerberos.json"})})," and should be in the root directory of the relevant stack or service definition. Kerberos Descriptors are meant to be hierarchical such that details in the stack-level descriptor can be overwritten (or updated) by details in the service-level descriptors."]}),"\n",(0,t.jsx)(n.p,{children:"For the services in a stack to be Kerberized, there must be a stack-level Kerberos Descriptor. This ensures that even if a common service has a Kerberos Descriptor, it may not be Kerberized unless the relevant stack indicates that supports Kerberos by having a stack-level Kerberos Descriptor."}),"\n",(0,t.jsx)(n.p,{children:"For a component of a service to be Kerberized, there must be an entry for it in its containing service's service-level descriptor. This allows for some of a services' components to be managed and other components of that service to be ignored by the automated Kerberos facility."}),"\n",(0,t.jsx)(n.p,{children:"Kerberos Descriptors are inherited from the base stack or service, but may be overridden as a full descriptor - partial descriptors are not allowed."}),"\n",(0,t.jsx)(n.p,{children:"A complete descriptor (which is built using the stack-level descriptor, the service-level descriptors, and any updates from user input) has the following structure:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Stack-level Properties"}),"\n",(0,t.jsx)(n.li,{children:"Stack-level Identities"}),"\n",(0,t.jsx)(n.li,{children:"Stack-level Configurations"}),"\n",(0,t.jsx)(n.li,{children:"Stack-level Auth-to-local-properties"}),"\n",(0,t.jsxs)(n.li,{children:["Services","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Service-level Identities"}),"\n",(0,t.jsx)(n.li,{children:"Service-level Auth-to-local-properties"}),"\n",(0,t.jsx)(n.li,{children:"Service-level Configurations"}),"\n",(0,t.jsxs)(n.li,{children:["Components","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Component-level Identities"}),"\n",(0,t.jsx)(n.li,{children:"Component-level Auth-to-local-properties"}),"\n",(0,t.jsx)(n.li,{children:"Component-level Configurations"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Each level of the descriptor inherits the data from its parent. This data, however, may be overridden if necessary. For example, a component will inherit the configurations and identities of its container service; which in turn inherits the configurations and identities from the stack."}),"\n",(0,t.jsx)("a",{name:"components-of-a-kerberos-descriptor"}),"\n",(0,t.jsx)(n.h3,{id:"components-of-a-kerberos-descriptor",children:"Components of a Kerberos Descriptor"}),"\n",(0,t.jsx)("a",{name:"stack-level-properties"}),"\n",(0,t.jsx)(n.h4,{id:"stack-level-properties",children:"Stack-level Properties"}),"\n",(0,t.jsxs)(n.p,{children:["Stack-level properties is an optional set of name/value pairs that can be used in variable replacements. For example, if a property named ",(0,t.jsx)(n.code,{children:"**_property1_**"})," exists with the value of ",(0,t.jsx)(n.code,{children:"**_value1_**"}),", then any instance of ",(0,t.jsx)(n.code,{children:"**_${property1}_**"})," within a configuration property name or configuration property value will be replaced with ",(0,t.jsx)(n.code,{children:"**_value1_**"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"This property is only relevant in the stack-level Kerberos Descriptor and may not be overridden by lower-level descriptors."}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#properties",children:"properties"}),"."]}),"\n",(0,t.jsx)("a",{name:"stack-level-identities"}),"\n",(0,t.jsx)(n.h4,{id:"stack-level-identities",children:"Stack-level Identities"}),"\n",(0,t.jsxs)(n.p,{children:['Stack-level identities is an optional identities block containing a list of zero or more identity descriptors that are common among all services in the stack. An example of such an identity is the Ambari smoke test user, which is used by all services to perform service check operations. Service- and component-level identities may reference (and specialize) stack-level identities using the identity\u2019s name with a forward slash (/) preceding it. For example if there was a stack-level identity with the name "smokeuser", then a service or a component may create an identity block that references and specializes it by declaring a "',(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"reference"})}),'" property and setting it to "/smokeuser". Within this identity block details of the identity may be and overwritten as necessary. This does not alter the stack-level identity, it essentially creates a copy of it and updates the copy\'s properties.']}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#identities",children:"identities"}),"."]}),"\n",(0,t.jsx)("a",{name:"stack-level-auth-to-local-properties"}),"\n",(0,t.jsx)(n.h4,{id:"stack-level-auth-to-local-properties",children:"Stack-level Auth-to-local-properties"}),"\n",(0,t.jsxs)(n.p,{children:["Stack-level auth-to-local-properties is an optional list of zero or more configuration property specifications ",(0,t.jsx)(n.code,{children:"(config-type/property_name[|concatenation_scheme])"})," indicating which properties should be updated with dynamically generated auto-to-local rule sets."]}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#auth-to-local-properties",children:"auth-to-local-properties"}),"."]}),"\n",(0,t.jsx)("a",{name:"stack-level-configurations"}),"\n",(0,t.jsx)(n.h4,{id:"stack-level-configurations",children:"Stack-level Configurations"}),"\n",(0,t.jsx)(n.p,{children:"Stack-level configurations is an optional configurations block containing a list of zero or more configuration descriptors that are common among all services in the stack. Configuration descriptors are overridable due to the structure of the data. However, overriding configuration properties may create undesired behavior since it is not known until after the Kerberization process is complete what value a property will have."}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#configurations",children:"configurations"}),"."]}),"\n",(0,t.jsx)("a",{name:"services"}),"\n",(0,t.jsx)(n.h4,{id:"services",children:"Services"}),"\n",(0,t.jsx)(n.p,{children:"Services is a list of zero or more service descriptors. A stack-level Kerberos Descriptor should not list any services; however a service-level Kerberos Descriptor should contain at least one."}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#services",children:"services"}),"."]}),"\n",(0,t.jsx)("a",{name:"service-level-identities"}),"\n",(0,t.jsx)(n.h4,{id:"service-level-identities",children:"Service-level Identities"}),"\n",(0,t.jsx)(n.p,{children:"Service-level identities is an optional identities block containing a list of zero or more identity descriptors that are common among all components of the service. Component-level identities may reference (and specialize) service-level identities by specifying a relative or an absolute path to it."}),"\n",(0,t.jsx)(n.p,{children:'For example if there was a service-level identity with the name "service_identity", then a child component may create an identity block that references and specializes it by setting its "reference" attribute to "../service_identity" or "/service_name/service_identity" and overriding any values as necessary. This does not override the service-level identity, it essentially creates a copy of it and updates the copy\'s properties.'}),"\n",(0,t.jsx)(n.h5,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'{\n  "name" : "relative_path_example",\n  "reference" : "../service_identity",\n  ...\n}\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'{\n  "name" : "absolute_path_example",\n  "reference" : "/SERVICE/service_identity",\n  ...\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note"}),": By using the absolute path to an identity, any service-level identity may be referenced by any other service or component."]}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#identities",children:"identities"}),"."]}),"\n",(0,t.jsx)("a",{name:"service-level-auth-to-local-properties"}),"\n",(0,t.jsx)(n.h4,{id:"service-level-auth-to-local-properties",children:"Service-level Auth-to-local-properties"}),"\n",(0,t.jsxs)(n.p,{children:["Service-level auth-to-local-properties is an optional list of zero or more configuration property specifications ",(0,t.jsx)(n.code,{children:"(config-type/property_name[|concatenation_scheme])"})," indicating which properties should be updated with dynamically generated auto-to-local rule sets."]}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#auth-to-local-properties",children:"auth-to-local-properties"}),"."]}),"\n",(0,t.jsx)("a",{name:"service-level-configurations"}),"\n",(0,t.jsx)(n.h4,{id:"service-level-configurations",children:"Service-level Configurations"}),"\n",(0,t.jsx)(n.p,{children:"Service-level configurations is an optional configurations block listing of zero or more configuration descriptors that are common among all components within a service. Configuration descriptors may be overridden due to the structure of the data. However, overriding configuration properties may create undesired behavior since it is not known until after the Kerberization process is complete what value a property will have."}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#configurations",children:"configurations"}),"."]}),"\n",(0,t.jsx)("a",{name:"service-components"}),"\n",(0,t.jsx)(n.h4,{id:"components",children:"Components"}),"\n",(0,t.jsx)(n.p,{children:"Components is a list of zero or more component descriptor blocks."}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#components",children:"components"}),"."]}),"\n",(0,t.jsx)("a",{name:"component-level-identities"}),"\n",(0,t.jsx)(n.h4,{id:"component-level-identities",children:"Component-level Identities"}),"\n",(0,t.jsxs)(n.p,{children:["Component-level identities is an optional identities block containing a list of zero or more identity descriptors that are specific to the component. A Component-level identity may be referenced (and specialized) by using the absolute path to it (",(0,t.jsx)(n.code,{children:"/service_name/component_name/identity_name"}),"). This does not override the component-level identity, it essentially creates a copy of it and updates the copy's properties."]}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#identities",children:"identities"}),"."]}),"\n",(0,t.jsx)("a",{name:"component-level-auth-to-local-properties"}),"\n",(0,t.jsx)(n.h4,{id:"component-level-auth-to-local-properties",children:"Component-level Auth-to-local-properties"}),"\n",(0,t.jsxs)(n.p,{children:["Component-level auth-to-local-properties is an optional list of zero or more configuration property specifications ",(0,t.jsx)(n.code,{children:"(config-type/property_name[|concatenation_scheme])"})," indicating which properties should be updated with dynamically generated auto-to-local rule sets."]}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#auth-to-local-properties",children:"auth-to-local-properties"}),"."]}),"\n",(0,t.jsx)("a",{name:"component-level-configurations"}),"\n",(0,t.jsx)(n.h4,{id:"component-level-configurations",children:"Component-level Configurations"}),"\n",(0,t.jsx)(n.p,{children:"Component-level configurations is an optional configurations block listing zero or more configuration descriptors that are specific to the component."}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"#configurations",children:"configurations"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"kerberos-descriptor-specifications",children:"Kerberos Descriptor Specifications"}),"\n",(0,t.jsx)("a",{name:"properties"}),"\n",(0,t.jsx)(n.h4,{id:"properties",children:"properties"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"properties"})," block is only valid in the service-level Kerberos Descriptor file. This block is a set of name/value pairs as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'"properties" : {\n  "property_1" : "value_1",\n  "property_2" : "value_2",\n  ...\n}\n'})}),"\n",(0,t.jsx)("a",{name:"auth-to-local-properties"}),"\n",(0,t.jsx)(n.h4,{id:"auth-to-local-properties",children:"auth-to-local-properties"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"auth-to-local-properties"})," block is valid in the stack-, service-, and component-level descriptors. This block is a list of configuration specifications (",(0,t.jsx)(n.code,{children:"config-type/property_name[|concatenation_scheme]"}),") indicating which properties contain auth-to-local rules that should be dynamically updated based on the identities used within the Kerberized cluster."]}),"\n",(0,t.jsx)(n.p,{children:"The specification optionally declares the concatenation scheme to use to append the rules into a rule set value. If specified one of the following schemes may be set:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"new_lines"})})," - rules in the rule set are separated by a new line (",(0,t.jsx)(n.code,{children:"\\n"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"new_lines_escaped"})})," - rules in the rule set are separated by a ",(0,t.jsx)(n.code,{children:"\\"})," and a new line (",(0,t.jsx)(n.code,{children:"\\n"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"spaces"})})," - rules in the rule set are separated by a whitespace character (effectively placing all rules in a single line)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If not specified, the default concatenation scheme is ",(0,t.jsx)(n.code,{children:"new_lines"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'"auth-to-local-properties" : [\n  "core-site/hadoop.security.auth_to_local",\n  "service.properties/http.authentication.kerberos.name.rules|new_lines_escaped",\n  ...\n]\n'})}),"\n",(0,t.jsx)("a",{name:"configurations"}),"\n",(0,t.jsx)(n.h4,{id:"configurations",children:"configurations"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"configurations"})," block may exist in stack-, service-, and component-level descriptors. This block is a list of one or more configuration blocks containing a single structure named using the configuration type and containing values for each relevant property."]}),"\n",(0,t.jsxs)(n.p,{children:["Each property name and value may be a concrete value or contain variables to be replaced using values from the stack-level ",(0,t.jsx)(n.code,{children:"properties"})," block or any available configuration. Properties from the ",(0,t.jsx)(n.code,{children:"properties"})," block are referenced by name (",(0,t.jsx)(n.code,{children:"${property_name}"}),"), configuration properties are reference by configuration specification (",(0,t.jsx)(n.code,{children:"${config-type/property_name}"}),") and kerberos principals are referenced by the principal path (",(0,t.jsx)(n.code,{children:"principals/SERVICE/COMPONENT/principal_name"}),")."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'"configurations" : [\n  {\n    "config-type-1" : {\n      "${cluster-env/smokeuser}_property" : "value1",\n      "some_realm_property" : "${realm}",\n       ...\n    }\n  },\n  {\n    "config-type-2" : {\n      "property-2" : "${cluster-env/smokeuser}",\n      ...\n    }\n  },\n  ...\n]\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"cluster-env/smokuser"})," was ",(0,t.jsx)(n.code,{children:'"ambari-qa"'})," and realm was ",(0,t.jsx)(n.code,{children:'"EXAMPLE.COM"'}),", the above block would effectively be translated to"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'"configurations" : [\n  {\n    "config-type-1" : {\n      "ambari-qa_property" : "value1",\n      "some_realm_property" : "EXAMPLE.COM",\n      ...\n    }\n  },\n  {\n    "config-type-2" : {\n      "property-2" : "ambari-qa",\n      ...\n    }\n  },\n  ...\n]\n'})}),"\n",(0,t.jsx)("a",{name:"identities"}),"\n",(0,t.jsx)(n.h4,{id:"identities",children:"identities"}),"\n",(0,t.jsxs)(n.p,{children:["An ",(0,t.jsx)(n.code,{children:"identities"})," descriptor may exist in stack-, service-, and component-level descriptors. This block is a list of zero or more identity descriptors. Each identity descriptor is a block containing a ",(0,t.jsx)(n.code,{children:"name"}),", an optional ",(0,t.jsx)(n.code,{children:"reference"})," identifier, an optional ",(0,t.jsx)(n.code,{children:"principal"})," descriptor, and an optional ",(0,t.jsx)(n.code,{children:"keytab"})," descriptor."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"name"})," property of an ",(0,t.jsx)(n.code,{children:"identity"})," descriptor should be a concrete name that is unique with in its ",(0,t.jsx)(n.code,{children:"local"})," scope (stack, service, or component). However, to maintain backwards-compatibility with previous versions of Ambari, it may be a reference identifier to some other identity in the Kerberos Descriptor. This feature is deprecated and may not be available in future versions of Ambari."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"reference"})," property of an ",(0,t.jsx)(n.code,{children:"identitiy"})," descriptor is optional. If it exists, it indicates that the properties from referenced identity is to be used as the base for the current identity and any properties specified in the local identity block overrides the base data. In this scenario, the base data is copied to the local identities and therefore changes are realized locally, not globally. Referenced identities may be hierarchical, so a referenced identity may reference another identity, and so on. Because of this, care must be taken not to create cyclic references. Reference values must be in the form of a relative or absolute ",(0,t.jsx)(n.em,{children:"path"})," to the referenced identity descriptor. Relative ",(0,t.jsx)(n.em,{children:"paths"})," start with a ",(0,t.jsx)(n.code,{children:"../"})," and may be specified in component-level identity descriptors to reference an identity descriptor in the parent service. Absolute ",(0,t.jsx)(n.em,{children:"paths"})," start with a ",(0,t.jsx)(n.code,{children:"/"})," and may be specified at any level as follows:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stack-level"})," identity reference: ",(0,t.jsx)(n.code,{children:"/identitiy_name"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service-level"})," identity reference: ",(0,t.jsx)(n.code,{children:"/SERVICE_NAME/identitiy_name"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Component-level"})," identity reference: ",(0,t.jsx)(n.code,{children:"/SERVICE_NAME/COMPONENT_NAME/identitiy_name"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'"identities" : [\n  {\n    "name" : "local_identity",\n    "principal" : {\n      ...\n    },\n    "keytab" : {\n      ...\n    }\n  },\n  {\n    "name" : "/smokeuser",\n    "principal" : {\n      "configuration" : "service-site/principal_property_name"\n    },\n    "keytab" : {\n      "configuration" : "service-site/keytab_property_name"\n    }\n  },\n  ...\n]\n'})}),"\n",(0,t.jsx)("a",{name:"principal"}),"\n",(0,t.jsx)(n.h4,{id:"principal",children:"principal"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"principal"})," block is an optional block inside an ",(0,t.jsx)(n.code,{children:"identity"})," descriptor block. It declares the details about the identity\u2019s principal, including the principal\u2019s ",(0,t.jsx)(n.code,{children:"value"}),", the ",(0,t.jsx)(n.code,{children:"type"})," (user or service), the relevant ",(0,t.jsx)(n.code,{children:"configuration"})," property, and a local username mapping. All properties are optional; however if no base or default value is available (via the parent identity's ",(0,t.jsx)(n.code,{children:"reference"})," value) for all properties, the principal may be ignored."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"value"})," property of the principal is expected to be the normalized principal name, including the principal\u2019s components and realm. In most cases, the realm should be specified using the realm variable (",(0,t.jsx)(n.code,{children:"${realm}"})," or ",(0,t.jsx)(n.code,{children:"${kerberos-env/realm}"}),'). Also, in the case of a service principal, "',(0,t.jsx)(n.code,{children:"_HOST"}),'" should be used to represent the relevant hostname. This value is typically replaced on the agent side by either the agent-side scripts or the services themselves to be the hostname of the current host. However the built-in hostname variable (',(0,t.jsx)(n.code,{children:"${hostname}"}),') may be used if "',(0,t.jsx)(n.code,{children:"_HOST"}),'" replacement on the agent-side is not available for the service. Examples: ',(0,t.jsx)(n.code,{children:"smokeuser@${realm}"}),", ",(0,t.jsx)(n.code,{children:"service/_HOST@${realm}"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"type"})," property of the principal may be either ",(0,t.jsx)(n.code,{children:"user"})," or ",(0,t.jsx)(n.code,{children:"service"}),". If not specified, the type is assumed to be ",(0,t.jsx)(n.code,{children:"user"}),". This value dictates how the identity is to be created in the KDC or Active Directory. It is especially important in the Active Directory case due to how accounts are created. It also, indicates to Ambari how to handle the principal and relevant keytab file reguarding the user interface behavior and data caching."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"configuration"})," property is an optional configuration specification (",(0,t.jsx)(n.code,{children:"config-type/property_name"}),") that is to be set to this principal's ",(0,t.jsx)(n.code,{children:"value"})," (after its variables have been replaced)."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"local_username"})," property, if supplied, indicates which local user account to use when generating auth-to-local rules for this identity. If not specified, no explicit auth-to-local rule will be generated."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'"principal" : {\n  "value": "${cluster-env/smokeuser}@${realm}",\n  "type" : "user" ,\n  "configuration": "cluster-env/smokeuser_principal_name",\n  "local_username" : "${cluster-env/smokeuser}"\n}\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'"principal" : {\n  "value": "component1/_HOST@${realm}",\n  "type" : "service" ,\n  "configuration": "service-site/component1.principal"\n}\n'})}),"\n",(0,t.jsx)("a",{name:"keytab"}),"\n",(0,t.jsx)(n.h4,{id:"keytab",children:"keytab"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"keytab"})," block is an optional block inside an ",(0,t.jsx)(n.code,{children:"identity"})," descriptor block. It describes how to create and store the relevant keytab file. This block declares the keytab file's path in the local filesystem of the destination host, the permissions to assign to that file, and the relevant configuration property."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"file"})," property declares an absolute path to use to store the keytab file when distributing to relevant hosts. If this is not supplied, the keytab file will not be created."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"owner"})," property is an optional block indicating the local user account to assign as the owner of the file and what access (",(0,t.jsx)(n.code,{children:'"rw"'})," - read/write; ",(0,t.jsx)(n.code,{children:'"r"'})," - read-only) should be granted to that user. By default, the owner will be given read-only access."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"group"})," property is an optional block indicating which local group to assigned as the group owner of the file and what access (",(0,t.jsx)(n.code,{children:'"rw"'})," - read/write; ",(0,t.jsx)(n.code,{children:'"r"'})," - read-only; ",(0,t.jsx)(n.code,{children:"\u201c\u201d"})," - no access) should be granted to local user accounts in that group. By default, the group will be given no access."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"configuration"})," property is an optional configuration specification (",(0,t.jsx)(n.code,{children:"config-type/property_name"}),") that is to be set to the path of this keytabs file (after any variables have been replaced)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'"keytab" : {\n  "file": "${keytab_dir}/smokeuser.headless.keytab",\n  "owner": {\n    "name": "${cluster-env/smokeuser}",\n    "access": "r"\n  },\n  "group": {\n    "name": "${cluster-env/user_group}",\n    "access": "r"\n  },\n  "configuration": "${cluster-env/smokeuser_keytab}"\n}\n'})}),"\n",(0,t.jsx)("a",{name:"services"}),"\n",(0,t.jsx)(n.h4,{id:"services-1",children:"services"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"services"})," block may exist in the stack-level and the service-level Kerberos Descriptor file. This block is a list of zero or more service descriptors to add to the Kerberos Descriptor."]}),"\n",(0,t.jsxs)(n.p,{children:["Each service block contains a service ",(0,t.jsx)(n.code,{children:"name"}),", and optionals ",(0,t.jsx)(n.code,{children:"identities"}),", ",(0,t.jsx)(n.code,{children:"auth_to_local_properties"})," ",(0,t.jsx)(n.code,{children:"configurations"}),", and ",(0,t.jsx)(n.code,{children:"components"})," blocks."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'"services": [\n  {\n    "name": "SERVICE1_NAME",\n    "identities": [\n      ...\n    ],\n    "auth_to_local_properties" : [\n      ...\n    ],\n    "configurations": [\n      ...\n    ],\n    "components": [\n      ...\n    ]\n  },\n  {\n    "name": "SERVICE2_NAME",\n    "identities": [\n      ...\n    ],\n    "auth_to_local_properties" : [\n      ...\n    ],\n    "configurations": [\n      ...\n    ],\n    "components": [\n      ...\n    ]\n  },\n  \u2026\n]\n'})}),"\n",(0,t.jsx)("a",{name:"components"}),"\n",(0,t.jsx)(n.h4,{id:"components-1",children:"components"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"components"})," block may exist within a ",(0,t.jsx)(n.code,{children:"service"})," descriptor block. This block is a list of zero or more component descriptors belonging to the containing service descriptor. Each component descriptor is a block containing a component ",(0,t.jsx)(n.code,{children:"name"}),", and optional ",(0,t.jsx)(n.code,{children:"identities"}),", ",(0,t.jsx)(n.code,{children:"auth_to_local_properties"}),", and ",(0,t.jsx)(n.code,{children:"configurations"})," blocks."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'"components": [\n  {\n    "name": "COMPONENT_NAME",\n    "identities": [\n      ...\n    ],\n    "auth_to_local_properties" : [\n      ...\n    ],\n    "configurations": [\n      ...\n    ]\n  },\n  ...\n]\n'})}),"\n",(0,t.jsx)("a",{name:"examples"}),"\n",(0,t.jsx)(n.h3,{id:"examples-1",children:"Examples"}),"\n",(0,t.jsx)(n.h4,{id:"example-stack-level-kerberos-descriptor",children:"Example Stack-level Kerberos Descriptor"}),"\n",(0,t.jsx)(n.p,{children:"The following example is annotated for descriptive purposes. The annotations are not valid in a real JSON-formatted file."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'{\n  // Properties that can be used in variable replacement operations.\n  // For example, ${keytab_dir} will resolve to "/etc/security/keytabs".\n  // Since variable replacement is recursive, ${realm} will resolve\n  // to ${kerberos-env/realm}, which in-turn will resolve to the\n  // declared default realm for the cluster\n  "properties": {\n    "realm": "${kerberos-env/realm}",\n    "keytab_dir": "/etc/security/keytabs"\n  },\n  // A list of global Kerberos identities. These may be referenced\n  // using /identity_name. For example the \u201cspnego\u201d identity may be\n  // referenced using \u201c/spnego\u201d\n  "identities": [\n    {\n      "name": "spnego",\n      // Details about this identity\'s principal. This instance does not\n      // declare any value for configuration or local username. That is\n      // left up to the services and components use wish to reference\n      // this principal and set overrides for those values.\n      "principal": {\n        "value": "HTTP/_HOST@${realm}",\n        "type" : "service"\n      },\n      // Details about this identity\u2019s keytab file. This keytab file\n      // will be created in the configured keytab file directory with\n      // read-only access granted to root and users in the cluster\u2019s\n      // default user group (typically, hadoop). To ensure that only\n      // a single copy exists on the file system, references to this\n      // identity should not override the keytab file details;\n      // however if it is desired that multiple keytab files are\n      // created, these values may be overridden in a reference\n      // within a service or component. Since no configuration\n      // specification is set, the the keytab file location will not\n      // be set in any configuration file by default. Services and\n      // components need to reference this identity to update this\n      // value as needed.\n      "keytab": {\n        "file": "${keytab_dir}/spnego.service.keytab",\n        "owner": {\n          "name": "root",\n          "access": "r"\n        },\n        "group": {\n          "name": "${cluster-env/user_group}",\n          "access": "r"\n        }\n      }\n    },\n    {\n      "name": "smokeuser",\n      // Details about this identity\'s principal. This instance declares\n      // a configuration and local username mapping. Services and\n      // components can override this to set additional configurations\n      // that should be set to this principal value.  Overriding the\n      // local username may create undesired behavior since there may be\n      // conflicting entries in relevant auth-to-local rule sets.\n      "principal": {\n        "value": "${cluster-env/smokeuser}@${realm}",\n        "type" : "user",\n        "configuration": "cluster-env/smokeuser_principal_name",\n        "local_username" : "${cluster-env/smokeuser}"\n      },\n      // Details about this identity\u2019s keytab file. This keytab file\n      // will be created in the configured keytab file directory with\n      // read-only access granted to the configured smoke user\n      // (typically ambari-qa) and users in the cluster\u2019s default\n      // user group (typically hadoop). To ensure that only a single\n      // copy exists on the file system, references to this identity\n      // should not override the keytab file details; however if it\n      // is desired that multiple keytab files are created, these\n      // values may be overridden in a reference within a service or\n      // component.\n      "keytab": {\n        "file": "${keytab_dir}/smokeuser.headless.keytab",\n        "owner": {\n          "name": "${cluster-env/smokeuser}",\n          "access": "r"\n        },\n        "group": {\n          "name": "${cluster-env/user_group}",\n          "access": "r"\n        },\n        "configuration": "cluster-env/smokeuser_keytab"\n      }\n    }\n  ]\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"example-service-level-kerberos-descriptor",children:"Example Service-level Kerberos Descriptor"}),"\n",(0,t.jsx)(n.p,{children:"The following example is annotated for descriptive purposes. The annotations are not valid in a real JSON-formatted file."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'{\n  // One or more services may be listed in a service-level Kerberos\n  // Descriptor file\n  "services": [\n    {\n      "name": "SERVICE_1",\n      // Service-level identities to be created if this service is installed.\n      // Any relevant keytab files will be distributed to hosts with at least\n      // one of the components on it.\n      "identities": [\n        // Service-specific identity declaration, declaring all properties\n        // needed initiate the creation of the principal and keytab files,\n        // as well as setting the service-specific  configurations.  This may\n        // be referenced by contained components using ../service1_identity.\n        {\n          "name": "service1_identity",\n          "principal": {\n            "value": "service1/_HOST@${realm}",\n            "type" : "service",\n            "configuration": "service1-site/service1.principal"\n          },\n          "keytab": {\n            "file": "${keytab_dir}/service1.service.keytab",\n            "owner": {\n              "name": "${service1-env/service_user}",\n              "access": "r"\n            },\n            "group": {\n              "name": "${cluster-env/user_group}",\n              "access": "r"\n            },\n            "configuration": "service1-site/service1.keytab.file"\n          }\n        },\n        // Service-level identity referencing the stack-level spnego\n        // identity and overriding the principal and keytab configuration\n        // specifications.\n        {\n          "name": "service1_spnego",\n          "reference": "/spnego",\n          "principal": {\n            "configuration": "service1-site/service1.web.principal"\n          },\n          "keytab": {\n            "configuration": "service1-site/service1.web.keytab.file"\n          }\n        },\n        // Service-level identity referencing the stack-level smokeuser\n        // identity. No properties are being overridden and overriding\n        // the principal and keytab configuration specifications.\n        // This ensures that the smokeuser principal is created and its\n        // keytab file is distributed to all hosts where components of this\n        // this service are installed.\n        {\n          "name": "service1_smokeuser",\n          "reference": "/smokeuser"\n        }\n      ],\n      // Properties related to this service that require the auth-to-local\n      // rules to be dynamically generated based on identities create for\n      // the cluster.\n      "auth_to_local_properties" : [\n        "service1-site/security.auth_to_local"\n      ],\n      // Configuration properties to be set when this service is installed,\n      // no matter which components are installed\n      "configurations": [\n        {\n          "service-site": {\n            "service1.security.authentication": "kerberos",\n            "service1.security.auth_to_local": ""\n          }\n        }\n      ],\n      // A list of components related to this service\n      "components": [\n        {\n          "name": "COMPONENT_1",\n          // Component-specific identities to be created when this component\n          // is installed.  Any keytab files specified will be distributed\n          // only to the hosts where this component is installed.\n          "identities": [\n            // An identity "local" to this component\n            {\n              "name": "component1_service_identity",\n              "principal": {\n                "value": "component1/_HOST@${realm}",\n                "type" : "service",\n                "configuration": "service1-site/comp1.principal",\n                "local_username" : "${service1-env/service_user}"\n              },\n              "keytab": {\n                "file": "${keytab_dir}/s1c1.service.keytab",\n                "owner": {\n                  "name": "${service1-env/service_user}",\n                  "access": "r"\n                },\n                "group": {\n                  "name": "${cluster-env/user_group}",\n                  "access": ""\n                },\n                "configuration": "service1-site/comp1.keytab.file"\n              }\n            },\n            // The stack-level spnego identity overridden to set component-specific\n            // configurations\n            {\n              "name": "component1_spnego_1",\n              "reference": "/spnego",\n              "principal": {\n                "configuration": "service1-site/comp1.spnego.principal"\n              },\n              "keytab": {\n                "configuration": "service1-site/comp1.spnego.keytab.file"\n              }\n            },\n            // The stack-level spnego identity overridden to set a different set of component-specific\n            // configurations\n            {\n              "name": "component1_spnego_2",\n              "reference": "/spnego",\n              "principal": {\n                "configuration": "service1-site/comp1.someother.principal"\n              },\n              "keytab": {\n                "configuration": "service1-site/comp1.someother.keytab.file"\n              }\n            }\n          ],\n          // Component-specific configurations to set if this component is installed\n          "configurations": [\n            {\n              "service-site": {\n                "comp1.security.type": "kerberos"\n              }\n            }\n          ]\n        },\n        {\n          "name": "COMPONENT_2",\n          "identities": [\n            {\n              "name": "component2_service_identity",\n              "principal": {\n                "value": "component2/_HOST@${realm}",\n                "type" : "service",\n                "configuration": "service1-site/comp2.principal",\n                "local_username" : "${service1-env/service_user}"\n              },\n              "keytab": {\n                "file": "${keytab_dir}/s1c2.service.keytab",\n                "owner": {\n                  "name": "${service1-env/service_user}",\n                  "access": "r"\n                },\n                "group": {\n                  "name": "${cluster-env/user_group}",\n                  "access": ""\n                },\n                "configuration": "service1-site/comp2.keytab.file"\n              }\n            },\n            // The service-level service1_identity identity overridden to\n            // set component-specific configurations\n            {\n              "name": "component2_service1_identity",\n              "reference": "../service1_identity",\n              "principal": {\n                "configuration": "service1-site/comp2.service.principal"\n              },\n              "keytab": {\n                "configuration": "service1-site/comp2.service.keytab.file"\n              }\n            }\n          ],\n          "configurations" : [\n            {\n              "service-site" : {\n                "comp2.security.type": "kerberos"\n              }\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);